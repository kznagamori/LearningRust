# 再帰を使用しないシェルソート

シェルソートは、挿入ソートの一般化として知られており、特に小さな要素が配列の後ろにある場合に効果的なアルゴリズムです。再帰を使用せずに実装するシェルソートの例を以下に示します。このアルゴリズムでは、まずギャップを大きく取り、徐々に小さくしていきます。各ステップで挿入ソートのような処理を行い、最終的にはギャップが1になったときに通常の挿入ソートを行います。

## サンプルプログラム
```rust
// シェルソートを実行する関数
fn shell_sort<T: Ord>(arr: &mut [T]) {
    // ギャップの初期値を配列の長さの半分に設定
    let mut gap = arr.len() / 2;

    // ギャップが0より大きい間、処理を繰り返す
    while gap > 0 {
        // ギャップから配列の終わりまで繰り返す
        for i in gap..arr.len() {
            let mut j = i;
            // ギャップを使って後ろから比較していく
            while j >= gap && arr[j - gap] > arr[j] {
                // より小さい要素を前に移動
                arr.swap(j - gap, j);
                j -= gap;
            }
        }
        // ギャップを半分に減らす
        gap /= 2;
    }
}

fn main() {
    let mut arr = [9, 8, 3, 7, 5, 6, 4, 1];
    println!("Before sorting: {:?}", arr);
    // 配列にシェルソートを適用
    shell_sort(&mut arr);
    println!("After sorting: {:?}", arr);
}
```

このコードでは、`shell_sort` 関数がシェルソートの実装を担当しています。最初に配列の長さの半分をギャップとして設定し、そのギャップを使って各要素に対して挿入ソートのような操作を行います。各ステップの後にギャップを半分に減らし、最終的にギャップが1になるまで繰り返します。ギャップが1のとき、アルゴリズムは通常の挿入ソートと同じ動作をします。

`main` 関数では、サンプルの整数配列に対してシェルソートを適用し、ソート前後の配列を出力しています。

